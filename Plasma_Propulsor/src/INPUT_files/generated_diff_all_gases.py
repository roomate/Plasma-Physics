from scipy.constants import pi, e, k, m_e, c
from LPP0D import uB, v_th, mass, Reaction, h0, nu_m,R_ind_noble_gas,hL_GRONDEIN,hR_GRONDEIN,uB_GRONDEIN,hl,hr,Kappa_noble_gas
import numpy as np


def differentials(t, y, case):
    """This function has been generated by parser.py at 2025-12-05 21:17:07.214359."""

    global thruster, params
    [thruster, params, chem] = case
    R = chem.R

    ydot = [0]*len(y)
    ng = + y[1]
    d = thruster.volume()/thruster.total_area()

    hL = hl(thruster.L,ng,y[0],0,y[3],y[4],params.sigma)

    hR = hr(thruster.R,ng,y[0],0,y[3],y[4],params.sigma)

    A_eff_ion_loss = hL * 2 * np.pi * thruster.R**2 + 2 * np.pi * thruster.R * thruster.L * hR

    A_eff_ion_prod = np.pi * thruster.R**2 * (2-thruster.beta_ions)* hL + 2 * np.pi * thruster.R * thruster.L * hR

    A_n = np.pi * thruster.R**2 * (2-thruster.beta_neutrals) + 2 * np.pi * thruster.R * thruster.L

    # Species e^-
    ydot[0] = + (+1) * R['Ar']['e^-']['IONIZATION'].K(y[3]) * y[1] * y[0] \
        - (+ y[2] * uB_GRONDEIN(y[3], "Ar^+") ) * A_eff_ion_loss * thruster.volume()**(-1) 

    # Species Ar
    ydot[1] = + (-1) * R['Ar']['e^-']['IONIZATION'].K(y[3]) * y[1] * y[0] \
        + (params.Q0 / thruster.volume()) \
        - 0.25 * y[1] * v_th(y[4], "Ar") * thruster.open_area_neutrals()/thruster.volume()\
        + y[2] * uB_GRONDEIN(y[3], "Ar") * A_eff_ion_prod / thruster.volume()

    # Species Ar^+
    ydot[2] = + (+1) * R['Ar']['e^-']['IONIZATION'].K(y[3]) * y[1] * y[0] \
        \
        - y[2] * uB_GRONDEIN(y[3], "Ar^+") * A_eff_ion_loss * thruster.volume()**(-1) 

    # Electronic temperature
    Ploss =\
        + 7 * e * y[3]  * y[0] * uB_GRONDEIN(y[3], "Ar") * A_eff_ion_loss/thruster.volume() 
    Ploss +=\
        + R['Ar']['e^-']['IONIZATION'].K(y[3]) * e  * R['Ar']['e^-']['IONIZATION'].energy_loss(y[3])* y[1] * y[0] \
        + R['Ar']['e^-']['ELASTIC'].K(y[3]) * e  * R['Ar']['e^-']['ELASTIC'].energy_loss(y[3])* y[1] * y[0] \
        + R['Ar']['e^-']['EXCITATION1'].K(y[3]) * e  * R['Ar']['e^-']['EXCITATION1'].energy_loss(y[3])* y[1] * y[0] \
        + R['Ar']['e^-']['EXCITATION2'].K(y[3]) * e  * R['Ar']['e^-']['EXCITATION2'].energy_loss(y[3])* y[1] * y[0] \
        + R['Ar']['e^-']['EXCITATION3'].K(y[3]) * e  * R['Ar']['e^-']['EXCITATION3'].energy_loss(y[3])* y[1] * y[0]  
    Pabs = 0.5 * R_ind_noble_gas(y[0],y[1],y[3],y[4],thruster.r_coil,thruster.l_coil,thruster.w,thruster.N,R,'Ar') * params.I_coil**2 / thruster.volume()

    ydot[3] = (y[0] * e)**(-1) * ((2/3)*(Pabs - Ploss) - e * y[3] * ydot[0])

    # Gas temperature
    Energy_Source =\
        + 0.25 * y[0] * mass('Ar') * y[1] * uB_GRONDEIN(y[3], 'Ar')**2 * 1e-18 * v_th(y[4], 'Ar')\
        + (-1) * Kappa_noble_gas(y[4],"Ar") * thruster.total_area() /thruster.volume() * e / k * (y[4] - params.wall_temperature) * np.sqrt((2.405/thruster.R)**2+(np.pi/thruster.L)**2)\
        + y[0] * uB_GRONDEIN(y[3], "Ar") * A_eff_ion_loss * thruster.volume()**(-1) * 0.043 * 5 * e * y[3]

    ydot[4] = - y[4] * (ydot[1]) / (y[1]) + (1.5 * (y[1]) * e)**(-1) * (Energy_Source)

    return ydot
